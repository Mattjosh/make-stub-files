<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: http://leoeditor.com/leo_toc.html -->
<?xml-stylesheet ekr_test ?>
<leo_file xmlns:leo="http://leoeditor.com/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5" body_secondary_ratio="0.5">
	<global_window_position top="50" left="50" height="500" width="700"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20160126153016.3"><vh>Startup</vh></v>
<v t="ekr.20160128104714.1"><vh>Config files</vh>
<v t="ekr.20160128225533.1"><vh>@clean .gitignore</vh></v>
<v t="ekr.20160128102557.1"><vh>@clean example.cfg</vh></v>
<v t="ekr.20160128104639.1"><vh>@clean msf.cfg</vh></v>
<v t="ekr.20160126153220.1"><vh>@clean make_stub_files.cfg</vh></v>
</v>
<v t="ekr.20160128105006.1"><vh>Doc files</vh>
<v t="ekr.20160126153921.1"><vh>@edit README.md</vh></v>
</v>
<v t="ekr.20160128154704.1"><vh>Testing</vh>
<v t="ekr.20160128154715.1"><vh>@clean test/test_msf.py</vh>
<v t="ekr.20160128190252.1"><vh>setUp</vh></v>
<v t="ekr.20160128190112.1"><vh>test_pattern_class</vh></v>
<v t="ekr.20160128190224.1"><vh>test_is_known_type</vh></v>
</v>
</v>
<v t="ekr.20160128104639.1"></v>
<v t="ekr.20160126153212.1"><vh>@clean make_stub_files.py</vh>
<v t="ekr.20160126153212.3"><vh>class AstFormatter</vh>
<v t="ekr.20160126153212.4"><vh> f.Entries</vh>
<v t="ekr.20160126153212.5"><vh>f.format</vh></v>
<v t="ekr.20160126153212.6"><vh>f.visit</vh></v>
</v>
<v t="ekr.20160126153212.7"><vh>f.Contexts</vh>
<v t="ekr.20160126153212.8"><vh>f.ClassDef</vh></v>
<v t="ekr.20160126153212.9"><vh>f.FunctionDef</vh></v>
<v t="ekr.20160126153212.10"><vh>f.Interactive</vh></v>
<v t="ekr.20160126153212.11"><vh>f.Module</vh></v>
<v t="ekr.20160126153212.12"><vh>f.Lambda</vh></v>
</v>
<v t="ekr.20160126153212.13"><vh>f.Expressions</vh>
<v t="ekr.20160126153212.14"><vh>f.Expr</vh></v>
<v t="ekr.20160126153212.15"><vh>f.Expression</vh></v>
<v t="ekr.20160126153212.16"><vh>f.GeneratorExp</vh></v>
<v t="ekr.20160126153212.17"><vh>f.ctx nodes</vh></v>
</v>
<v t="ekr.20160126153212.18"><vh>f.Operands</vh>
<v t="ekr.20160126153212.19"><vh>f.arguments</vh></v>
<v t="ekr.20160126153212.20"><vh>f.arg (Python3 only)</vh></v>
<v t="ekr.20160126153212.21"><vh>f.Attribute</vh></v>
<v t="ekr.20160126153212.22"><vh>f.Bytes</vh></v>
<v t="ekr.20160126153212.23"><vh>f.Call &amp; f.keyword</vh>
<v t="ekr.20160126153212.24"><vh>f.keyword</vh></v>
</v>
<v t="ekr.20160126153212.25"><vh>f.comprehension</vh></v>
<v t="ekr.20160126153212.26"><vh>f.Dict</vh></v>
<v t="ekr.20160126153212.27"><vh>f.Ellipsis</vh></v>
<v t="ekr.20160126153212.28"><vh>f.ExtSlice</vh></v>
<v t="ekr.20160126153212.29"><vh>f.Index</vh></v>
<v t="ekr.20160126153212.30"><vh>f.List</vh></v>
<v t="ekr.20160126153212.31"><vh>f.ListComp</vh></v>
<v t="ekr.20160126153212.32"><vh>f.Name</vh></v>
<v t="ekr.20160126153212.33"><vh>f.Num</vh></v>
<v t="ekr.20160126153212.34"><vh>f.Repr</vh></v>
<v t="ekr.20160126153212.35"><vh>f.Slice</vh></v>
<v t="ekr.20160126153212.36"><vh>f.Str</vh></v>
<v t="ekr.20160126153212.37"><vh>f.Subscript</vh></v>
<v t="ekr.20160126153212.38"><vh>f.Tuple</vh></v>
</v>
<v t="ekr.20160126153212.39"><vh>f.Operators</vh>
<v t="ekr.20160126153212.40"><vh>f.BinOp</vh></v>
<v t="ekr.20160126153212.41"><vh>f.BoolOp</vh></v>
<v t="ekr.20160126153212.42"><vh>f.Compare</vh></v>
<v t="ekr.20160126153212.43"><vh>f.UnaryOp</vh></v>
<v t="ekr.20160126153212.44"><vh>f.ifExp (ternary operator)</vh></v>
</v>
<v t="ekr.20160126153212.45"><vh>f.Statements</vh>
<v t="ekr.20160126153212.46"><vh>f.Assert</vh></v>
<v t="ekr.20160126153212.47"><vh>f.Assign</vh></v>
<v t="ekr.20160126153212.48"><vh>f.AugAssign</vh></v>
<v t="ekr.20160126153212.49"><vh>f.Break</vh></v>
<v t="ekr.20160126153212.50"><vh>f.Continue</vh></v>
<v t="ekr.20160126153212.51"><vh>f.Delete</vh></v>
<v t="ekr.20160126153212.52"><vh>f.ExceptHandler</vh></v>
<v t="ekr.20160126153212.53"><vh>f.Exec</vh></v>
<v t="ekr.20160126153212.54"><vh>f.For</vh></v>
<v t="ekr.20160126153212.55"><vh>f.Global</vh></v>
<v t="ekr.20160126153212.56"><vh>f.If</vh></v>
<v t="ekr.20160126153212.57"><vh>f.Import &amp; helper</vh>
<v t="ekr.20160126153212.58"><vh>f.get_import_names</vh></v>
</v>
<v t="ekr.20160126153212.59"><vh>f.ImportFrom</vh></v>
<v t="ekr.20160126153212.60"><vh>f.Pass</vh></v>
<v t="ekr.20160126153212.61"><vh>f.Print</vh></v>
<v t="ekr.20160126153212.62"><vh>f.Raise</vh></v>
<v t="ekr.20160126153212.63"><vh>f.Return</vh></v>
<v t="ekr.20160126153212.64"><vh>f.TryExcept</vh></v>
<v t="ekr.20160126153212.65"><vh>f.TryFinally</vh></v>
<v t="ekr.20160126153212.66"><vh>f.While</vh></v>
<v t="ekr.20160126153212.67"><vh>f.With</vh></v>
<v t="ekr.20160126153212.68"><vh>f.Yield</vh></v>
</v>
<v t="ekr.20160126153212.69"><vh>f.Utils</vh>
<v t="ekr.20160126153212.70"><vh>f.kind</vh></v>
<v t="ekr.20160126153212.71"><vh>f.indent</vh></v>
<v t="ekr.20160126153212.72"><vh>f.op_name</vh></v>
</v>
</v>
<v t="ekr.20160131180118.1"><vh>class LeoGlobals</vh>
<v t="ekr.20160131180244.1"><vh>g.pdb</vh></v>
<v t="ekr.20160131180306.1"><vh>g.trace</vh></v>
</v>
<v t="ekr.20160128041938.1"><vh>class Pattern</vh>
<v t="ekr.20160128113859.1"><vh>pattern.ctor</vh></v>
<v t="ekr.20160128113914.1"><vh>pattern.str &amp; repr</vh></v>
<v t="ekr.20160128042857.1"><vh>pattern.is_balanced</vh></v>
<v t="ekr.20160128042705.1" a="M"><vh>pattern.all_matches &amp; helpers</vh>
<v t="ekr.20160128051025.1"><vh>pattern.full_balanced_match</vh></v>
<v t="ekr.20160128045845.1"><vh>pattern.match_balanced</vh></v>
</v>
<v t="ekr.20160128114726.1"><vh>pattern.match_entire_string</vh></v>
<v t="ekr.20160131204607.1"><vh>pattern.replace</vh></v>
</v>
<v t="ekr.20160126153212.73"><vh>class StandAloneMakeStubFile</vh>
<v t="ekr.20160126153212.74"><vh>msf.ctor</vh></v>
<v t="ekr.20160126165907.1"><vh>msf.finalize</vh></v>
<v t="ekr.20160126153212.75"><vh>msf.make_stub_file</vh></v>
<v t="ekr.20160126153212.76"><vh>msf.run</vh></v>
<v t="ekr.20160128154243.1"><vh>msf.run_all_unit_tests</vh></v>
<v t="ekr.20160126153212.77"><vh>msf.scan_command_line</vh></v>
<v t="ekr.20160126153212.78"><vh>msf.scan_options &amp; helper</vh>
<v t="ekr.20160126153212.79"><vh>msf.scan_patterns</vh></v>
</v>
</v>
<v t="ekr.20160126153212.80"><vh>class StubFormatter (AstFormatter)</vh>
<v t="ekr.20160126153212.81"><vh>sf.Constants &amp; Name</vh></v>
<v t="ekr.20160201194801.1"><vh>sf.Return</vh></v>
</v>
<v t="ekr.20160126153212.82"><vh>class StubTraverser (ast.NodeVisitor)</vh>
<v t="ekr.20160126153212.83"><vh>st.ctor</vh></v>
<v t="ekr.20160126153212.84"><vh>st.indent &amp; out</vh></v>
<v t="ekr.20160126153212.85"><vh>st.run</vh></v>
<v t="ekr.20160126153212.87"><vh>st.visit_ClassDef</vh></v>
<v t="ekr.20160126153212.88"><vh>st.visit_FunctionDef &amp; helpers</vh>
<v t="ekr.20160126153212.89"><vh>st.format_arguments &amp; helper</vh>
<v t="ekr.20160126153212.91"><vh>st.munge_arg</vh></v>
</v>
<v t="ekr.20160126153212.90"><vh>st.format_returns &amp; helpers</vh>
<v t="ekr.20160130032546.1"><vh>st.format_return_expressions</vh></v>
<v t="ekr.20160130034812.1"><vh>st.is_known_type</vh></v>
<v t="ekr.20160128122410.1"><vh>st.get_def_name</vh></v>
<v t="ekr.20160126153212.92"><vh>st.munge_ret &amp; helper</vh>
<v t="ekr.20160126153212.93"><vh>st.match_ret_patterns</vh></v>
</v>
</v>
</v>
<v t="ekr.20160126153212.99"><vh>st.visit_Return</vh></v>
</v>
<v t="ekr.20160131175042.1"><vh>class TestClass</vh>
<v t="ekr.20160131175118.1"><vh>return_list</vh></v>
<v t="ekr.20160131192406.1"><vh>return_all</vh></v>
<v t="ekr.20160131192735.1"><vh>return_array</vh></v>
<v t="ekr.20160201125349.1"><vh>parse_group (Guido)</vh></v>
</v>
<v t="ekr.20160126153212.100"><vh>main</vh></v>
<v t="ekr.20160126172747.1"><vh>pdb</vh></v>
</v>
<v t="ekr.20160131174909.1"><vh>** To do</vh></v>
<v t="ekr.20160201151312.1"><vh>Recent</vh>
<v t="ekr.20160130034812.1"></v>
<v t="ekr.20160201131557.1"><vh>fix balanced replacement</vh></v>
<v t="ekr.20160128190224.1"></v>
<v t="ekr.20160128190112.1"></v>
<v t="ekr.20160128045845.1"></v>
<v t="ekr.20160126153212.63"></v>
<v t="ekr.20160126153212.99"></v>
</v>
<v t="ekr.20160201201820.1"><vh>Most recent</vh>
<v t="ekr.20160126153212.90"></v>
<v t="ekr.20160126153212.92"></v>
<v t="ekr.20160201194801.1"></v>
</v>
</vnodes>
<tnodes>
<t tx="ekr.20160126153016.3"></t>
<t tx="ekr.20160126153212.1">#!/usr/bin/env python
'''
This script makes a stub (.pyi) file in the output directory for each
source file listed on the command line (wildcard file names are supported).

For full details, see README.md.

This file is in the public domain.
'''

import ast
from collections import OrderedDict
    # Requires Python 2.7 or above. Without OrderedDict
    # the configparser will give random order for patterns.
try:
    import ConfigParser as configparser # Python 2
except ImportError:
    import configparser # Python 3
import glob
import optparse
import os
import re
import sys
@others
g = LeoGlobals() # For ekr.
if __name__ == "__main__":
    main()
</t>
<t tx="ekr.20160126153212.10">
def do_Interactive(self, node):
    for z in node.body:
        self.visit(z)
</t>
<t tx="ekr.20160126153212.100">
def main():
    '''
    The driver for the stand-alone version of make-stub-files.
    All options come from ~/stubs/make_stub_files.cfg.
    '''
    controller = StandAloneMakeStubFile()
    controller.scan_command_line()
    controller.scan_options()
    controller.run()
    print('done')
</t>
<t tx="ekr.20160126153212.11">
def do_Module(self, node):
    assert 'body' in node._fields
    result = ''.join([self.visit(z) for z in node.body])
    return result # 'module:\n%s' % (result)
</t>
<t tx="ekr.20160126153212.12">
def do_Lambda(self, node):
    return self.indent('lambda %s: %s' % (
        self.visit(node.args),
        self.visit(node.body)))
</t>
<t tx="ekr.20160126153212.13">
# Expressions...
</t>
<t tx="ekr.20160126153212.14">
def do_Expr(self, node):
    '''An outer expression: must be indented.'''
    return self.indent('%s\n' % self.visit(node.value))
</t>
<t tx="ekr.20160126153212.15">
def do_Expression(self, node):
    '''An inner expression: do not indent.'''
    return '%s\n' % self.visit(node.body)
</t>
<t tx="ekr.20160126153212.16">
def do_GeneratorExp(self, node):
    elt = self.visit(node.elt) or ''
    gens = [self.visit(z) for z in node.generators]
    gens = [z if z else '&lt;**None**&gt;' for z in gens] ### Kludge: probable bug.
    return '&lt;gen %s for %s&gt;' % (elt, ','.join(gens))
</t>
<t tx="ekr.20160126153212.17">
def do_AugLoad(self, node):
    return 'AugLoad'

def do_Del(self, node):
    return 'Del'

def do_Load(self, node):
    return 'Load'

def do_Param(self, node):
    return 'Param'

def do_Store(self, node):
    return 'Store'
</t>
<t tx="ekr.20160126153212.18">
# Operands...
</t>
<t tx="ekr.20160126153212.19">
# arguments = (expr* args, identifier? vararg, identifier? kwarg, expr* defaults)

def do_arguments(self, node):
    '''Format the arguments node.'''
    kind = self.kind(node)
    assert kind == 'arguments', kind
    args = [self.visit(z) for z in node.args]
    defaults = [self.visit(z) for z in node.defaults]
    # Assign default values to the last args.
    args2 = []
    n_plain = len(args) - len(defaults)
    for i in range(len(args)):
        if i &lt; n_plain:
            args2.append(args[i])
        else:
            args2.append('%s=%s' % (args[i], defaults[i - n_plain]))
    # Now add the vararg and kwarg args.
    name = getattr(node, 'vararg', None)
    if name: args2.append('*' + name)
    name = getattr(node, 'kwarg', None)
    if name: args2.append('**' + name)
    return ','.join(args2)
</t>
<t tx="ekr.20160126153212.20">
# Python 3:
# arg = (identifier arg, expr? annotation)

def do_arg(self, node):
    if node.annotation:
        return self.visit(node.annotation)
    else:
        return ''
</t>
<t tx="ekr.20160126153212.21">
# Attribute(expr value, identifier attr, expr_context ctx)

def do_Attribute(self, node):
    return '%s.%s' % (
        self.visit(node.value),
        node.attr) # Don't visit node.attr: it is always a string.
</t>
<t tx="ekr.20160126153212.22">
def do_Bytes(self, node): # Python 3.x only.
    return str(node.s)
</t>
<t tx="ekr.20160126153212.23">
# Call(expr func, expr* args, keyword* keywords, expr? starargs, expr? kwargs)

def do_Call(self, node):
    func = self.visit(node.func)
    args = [self.visit(z) for z in node.args]
    for z in node.keywords:
        # Calls f.do_keyword.
        args.append(self.visit(z))
    if getattr(node, 'starargs', None):
        args.append('*%s' % (self.visit(node.starargs)))
    if getattr(node, 'kwargs', None):
        args.append('**%s' % (self.visit(node.kwargs)))
    args = [z for z in args if z] # Kludge: Defensive coding.
    return '%s(%s)' % (func, ','.join(args))
</t>
<t tx="ekr.20160126153212.24">
# keyword = (identifier arg, expr value)

def do_keyword(self, node):
    # node.arg is a string.
    value = self.visit(node.value)
    # This is a keyword *arg*, not a Python keyword!
    return '%s=%s' % (node.arg, value)
</t>
<t tx="ekr.20160126153212.25">
def do_comprehension(self, node):
    result = []
    name = self.visit(node.target) # A name.
    it = self.visit(node.iter) # An attribute.
    result.append('%s in %s' % (name, it))
    ifs = [self.visit(z) for z in node.ifs]
    if ifs:
        result.append(' if %s' % (''.join(ifs)))
    return ''.join(result)
</t>
<t tx="ekr.20160126153212.26">
def do_Dict(self, node):
    result = []
    keys = [self.visit(z) for z in node.keys]
    values = [self.visit(z) for z in node.values]
    if len(keys) == len(values):
        result.append('{\n' if keys else '{')
        items = []
        for i in range(len(keys)):
            items.append('  %s:%s' % (keys[i], values[i]))
        result.append(',\n'.join(items))
        result.append('\n}' if keys else '}')
    else:
        print('Error: f.Dict: len(keys) != len(values)\nkeys: %s\nvals: %s' % (
            repr(keys), repr(values)))
    return ''.join(result)
</t>
<t tx="ekr.20160126153212.27">
def do_Ellipsis(self, node):
    return '...'
</t>
<t tx="ekr.20160126153212.28">
def do_ExtSlice(self, node):
    return ':'.join([self.visit(z) for z in node.dims])
</t>
<t tx="ekr.20160126153212.29">
def do_Index(self, node):
    return self.visit(node.value)
</t>
<t tx="ekr.20160126153212.3">

class AstFormatter:
    '''
    A class to recreate source code from an AST.
    
    This does not have to be perfect, but it should be close.
    '''
    # pylint: disable=consider-using-enumerate
    @others
</t>
<t tx="ekr.20160126153212.30">
def do_List(self, node):
    # Not used: list context.
    # self.visit(node.ctx)
    elts = [self.visit(z) for z in node.elts]
    elst = [z for z in elts if z] # Defensive.
    return '[%s]' % ','.join(elts)
</t>
<t tx="ekr.20160126153212.31">
def do_ListComp(self, node):
    elt = self.visit(node.elt)
    gens = [self.visit(z) for z in node.generators]
    gens = [z if z else '&lt;**None**&gt;' for z in gens] ### Kludge: probable bug.
    return '%s for %s' % (elt, ''.join(gens))
</t>
<t tx="ekr.20160126153212.32">
def do_Name(self, node):
    return node.id
</t>
<t tx="ekr.20160126153212.33">
def do_Num(self, node):
    return repr(node.n)
</t>
<t tx="ekr.20160126153212.34">
# Python 2.x only

def do_Repr(self, node):
    return 'repr(%s)' % self.visit(node.value)
</t>
<t tx="ekr.20160126153212.35">
def do_Slice(self, node):
    lower, upper, step = '', '', ''
    if getattr(node, 'lower', None) is not None:
        lower = self.visit(node.lower)
    if getattr(node, 'upper', None) is not None:
        upper = self.visit(node.upper)
    if getattr(node, 'step', None) is not None:
        step = self.visit(node.step)
    if step:
        return '%s:%s:%s' % (lower, upper, step)
    else:
        return '%s:%s' % (lower, upper)
</t>
<t tx="ekr.20160126153212.36">
def do_Str(self, node):
    '''This represents a string constant.'''
    return repr(node.s)
</t>
<t tx="ekr.20160126153212.37">
# Subscript(expr value, slice slice, expr_context ctx)

def do_Subscript(self, node):
    value = self.visit(node.value)
    the_slice = self.visit(node.slice)
    return '%s[%s]' % (value, the_slice)
</t>
<t tx="ekr.20160126153212.38">
def do_Tuple(self, node):
    elts = [self.visit(z) for z in node.elts]
    return '(%s)' % ','.join(elts)
</t>
<t tx="ekr.20160126153212.39">
# Operators...
</t>
<t tx="ekr.20160126153212.4">
# Entries...
</t>
<t tx="ekr.20160126153212.40">
def do_BinOp(self, node):
    return '%s%s%s' % (
        self.visit(node.left),
        self.op_name(node.op),
        self.visit(node.right))
</t>
<t tx="ekr.20160126153212.41">
def do_BoolOp(self, node):
    op_name = self.op_name(node.op)
    values = [self.visit(z) for z in node.values]
    return op_name.join(values)
</t>
<t tx="ekr.20160126153212.42">
def do_Compare(self, node):
    result = []
    lt = self.visit(node.left)
    ops = [self.op_name(z) for z in node.ops]
    comps = [self.visit(z) for z in node.comparators]
    result.append(lt)
    if len(ops) == len(comps):
        for i in range(len(ops)):
            result.append('%s%s' % (ops[i], comps[i]))
    else:
        print('can not happen: ops', repr(ops), 'comparators', repr(comps))
    return ''.join(result)
</t>
<t tx="ekr.20160126153212.43">
def do_UnaryOp(self, node):
    return '%s%s' % (
        self.op_name(node.op),
        self.visit(node.operand))
</t>
<t tx="ekr.20160126153212.44">
def do_IfExp(self, node):
    return '%s if %s else %s ' % (
        self.visit(node.body),
        self.visit(node.test),
        self.visit(node.orelse))
</t>
<t tx="ekr.20160126153212.45">
# Statements...
</t>
<t tx="ekr.20160126153212.46">
def do_Assert(self, node):
    test = self.visit(node.test)
    if getattr(node, 'msg', None):
        message = self.visit(node.msg)
        return self.indent('assert %s, %s' % (test, message))
    else:
        return self.indent('assert %s' % test)
</t>
<t tx="ekr.20160126153212.47">
def do_Assign(self, node):
    return self.indent('%s=%s\n' % (
        '='.join([self.visit(z) for z in node.targets]),
        self.visit(node.value)))
</t>
<t tx="ekr.20160126153212.48">
def do_AugAssign(self, node):
    return self.indent('%s%s=%s\n' % (
        self.visit(node.target),
        self.op_name(node.op), # Bug fix: 2013/03/08.
        self.visit(node.value)))
</t>
<t tx="ekr.20160126153212.49">
def do_Break(self, node):
    return self.indent('break\n')
</t>
<t tx="ekr.20160126153212.5">
def format(self, node):
    '''Format the node (or list of nodes) and its descendants.'''
    self.level = 0
    val = self.visit(node)
    return val and val.strip() or ''
</t>
<t tx="ekr.20160126153212.50">
def do_Continue(self, node):
    return self.indent('continue\n')
</t>
<t tx="ekr.20160126153212.51">
def do_Delete(self, node):
    targets = [self.visit(z) for z in node.targets]
    return self.indent('del %s\n' % ','.join(targets))
</t>
<t tx="ekr.20160126153212.52">
def do_ExceptHandler(self, node):
    result = []
    result.append(self.indent('except'))
    if getattr(node, 'type', None):
        result.append(' %s' % self.visit(node.type))
    if getattr(node, 'name', None):
        if isinstance(node.name, ast.AST):
            result.append(' as %s' % self.visit(node.name))
        else:
            result.append(' as %s' % node.name) # Python 3.x.
    result.append(':\n')
    for z in node.body:
        self.level += 1
        result.append(self.visit(z))
        self.level -= 1
    return ''.join(result)
</t>
<t tx="ekr.20160126153212.53">
# Python 2.x only

def do_Exec(self, node):
    body = self.visit(node.body)
    args = [] # Globals before locals.
    if getattr(node, 'globals', None):
        args.append(self.visit(node.globals))
    if getattr(node, 'locals', None):
        args.append(self.visit(node.locals))
    if args:
        return self.indent('exec %s in %s\n' % (
            body, ','.join(args)))
    else:
        return self.indent('exec %s\n' % (body))
</t>
<t tx="ekr.20160126153212.54">
def do_For(self, node):
    result = []
    result.append(self.indent('for %s in %s:\n' % (
        self.visit(node.target),
        self.visit(node.iter))))
    for z in node.body:
        self.level += 1
        result.append(self.visit(z))
        self.level -= 1
    if node.orelse:
        result.append(self.indent('else:\n'))
        for z in node.orelse:
            self.level += 1
            result.append(self.visit(z))
            self.level -= 1
    return ''.join(result)
</t>
<t tx="ekr.20160126153212.55">
def do_Global(self, node):
    return self.indent('global %s\n' % (
        ','.join(node.names)))
</t>
<t tx="ekr.20160126153212.56">
def do_If(self, node):
    result = []
    result.append(self.indent('if %s:\n' % (
        self.visit(node.test))))
    for z in node.body:
        self.level += 1
        result.append(self.visit(z))
        self.level -= 1
    if node.orelse:
        result.append(self.indent('else:\n'))
        for z in node.orelse:
            self.level += 1
            result.append(self.visit(z))
            self.level -= 1
    return ''.join(result)
</t>
<t tx="ekr.20160126153212.57">
def do_Import(self, node):
    names = []
    for fn, asname in self.get_import_names(node):
        if asname:
            names.append('%s as %s' % (fn, asname))
        else:
            names.append(fn)
    return self.indent('import %s\n' % (
        ','.join(names)))
</t>
<t tx="ekr.20160126153212.58">
def get_import_names(self, node):
    '''Return a list of the the full file names in the import statement.'''
    result = []
    for ast2 in node.names:
        if self.kind(ast2) == 'alias':
            data = ast2.name, ast2.asname
            result.append(data)
        else:
            print('unsupported kind in Import.names list', self.kind(ast2))
    return result
</t>
<t tx="ekr.20160126153212.59">
def do_ImportFrom(self, node):
    names = []
    for fn, asname in self.get_import_names(node):
        if asname:
            names.append('%s as %s' % (fn, asname))
        else:
            names.append(fn)
    return self.indent('from %s import %s\n' % (
        node.module,
        ','.join(names)))
</t>
<t tx="ekr.20160126153212.6">
def visit(self, node):
    '''Return the formatted version of an Ast node, or list of Ast nodes.'''
    if isinstance(node, (list, tuple)):
        return ','.join([self.visit(z) for z in node])
    elif node is None:
        return 'None'
    else:
        assert isinstance(node, ast.AST), node.__class__.__name__
        method_name = 'do_' + node.__class__.__name__
        method = getattr(self, method_name)
        s = method(node)
        # pylint: disable=unidiomatic-typecheck
        assert type(s) == type('abc'), type(s)
        return s
</t>
<t tx="ekr.20160126153212.60">
def do_Pass(self, node):
    return self.indent('pass\n')
</t>
<t tx="ekr.20160126153212.61">
# Python 2.x only

def do_Print(self, node):
    vals = []
    for z in node.values:
        vals.append(self.visit(z))
    if getattr(node, 'dest', None):
        vals.append('dest=%s' % self.visit(node.dest))
    if getattr(node, 'nl', None):
        vals.append('nl=%s' % node.nl)
    return self.indent('print(%s)\n' % (
        ','.join(vals)))
</t>
<t tx="ekr.20160126153212.62">
def do_Raise(self, node):
    args = []
    for attr in ('type', 'inst', 'tback'):
        if getattr(node, attr, None) is not None:
            args.append(self.visit(getattr(node, attr)))
    if args:
        return self.indent('raise %s\n' % (
            ','.join(args)))
    else:
        return self.indent('raise\n')
</t>
<t tx="ekr.20160126153212.63">
def do_Return(self, node):
    if node.value:
        return self.indent('return %s\n' % (
            self.visit(node.value)))
    else:
        return self.indent('return\n')
</t>
<t tx="ekr.20160126153212.64">
def do_TryExcept(self, node):
    result = []
    result.append(self.indent('try:\n'))
    for z in node.body:
        self.level += 1
        result.append(self.visit(z))
        self.level -= 1
    if node.handlers:
        for z in node.handlers:
            result.append(self.visit(z))
    if node.orelse:
        result.append('else:\n')
        for z in node.orelse:
            self.level += 1
            result.append(self.visit(z))
            self.level -= 1
    return ''.join(result)
</t>
<t tx="ekr.20160126153212.65">
def do_TryFinally(self, node):
    result = []
    result.append(self.indent('try:\n'))
    for z in node.body:
        self.level += 1
        result.append(self.visit(z))
        self.level -= 1
    result.append(self.indent('finally:\n'))
    for z in node.finalbody:
        self.level += 1
        result.append(self.visit(z))
        self.level -= 1
    return ''.join(result)
</t>
<t tx="ekr.20160126153212.66">
def do_While(self, node):
    result = []
    result.append(self.indent('while %s:\n' % (
        self.visit(node.test))))
    for z in node.body:
        self.level += 1
        result.append(self.visit(z))
        self.level -= 1
    if node.orelse:
        result.append('else:\n')
        for z in node.orelse:
            self.level += 1
            result.append(self.visit(z))
            self.level -= 1
    return ''.join(result)
</t>
<t tx="ekr.20160126153212.67">
def do_With(self, node):
    result = []
    result.append(self.indent('with '))
    if hasattr(node, 'context_expression'):
        result.append(self.visit(node.context_expresssion))
    vars_list = []
    if hasattr(node, 'optional_vars'):
        try:
            for z in node.optional_vars:
                vars_list.append(self.visit(z))
        except TypeError: # Not iterable.
            vars_list.append(self.visit(node.optional_vars))
    result.append(','.join(vars_list))
    result.append(':\n')
    for z in node.body:
        self.level += 1
        result.append(self.visit(z))
        self.level -= 1
    result.append('\n')
    return ''.join(result)
</t>
<t tx="ekr.20160126153212.68">
def do_Yield(self, node):
    if getattr(node, 'value', None):
        return self.indent('yield %s\n' % (
            self.visit(node.value)))
    else:
        return self.indent('yield\n')
</t>
<t tx="ekr.20160126153212.69">
# Utils...
</t>
<t tx="ekr.20160126153212.7">
# Contexts...
</t>
<t tx="ekr.20160126153212.70">
def kind(self, node):
    '''Return the name of node's class.'''
    return node.__class__.__name__
</t>
<t tx="ekr.20160126153212.71">
def indent(self, s):
    return '%s%s' % (' ' * 4 * self.level, s)
</t>
<t tx="ekr.20160126153212.72">
def op_name (self,node,strict=True):
    '''Return the print name of an operator node.'''
    d = {
        # Binary operators. 
        'Add':       '+',
        'BitAnd':    '&amp;',
        'BitOr':     '|',
        'BitXor':    '^',
        'Div':       '/',
        'FloorDiv':  '//',
        'LShift':    '&lt;&lt;',
        'Mod':       '%',
        'Mult':      '*',
        'Pow':       '**',
        'RShift':    '&gt;&gt;',
        'Sub':       '-',
        # Boolean operators.
        'And':   ' and ',
        'Or':    ' or ',
        # Comparison operators
        'Eq':    '==',
        'Gt':    '&gt;',
        'GtE':   '&gt;=',
        'In':    ' in ',
        'Is':    ' is ',
        'IsNot': ' is not ',
        'Lt':    '&lt;',
        'LtE':   '&lt;=',
        'NotEq': '!=',
        'NotIn': ' not in ',
        # Context operators.
        'AugLoad':  '&lt;AugLoad&gt;',
        'AugStore': '&lt;AugStore&gt;',
        'Del':      '&lt;Del&gt;',
        'Load':     '&lt;Load&gt;',
        'Param':    '&lt;Param&gt;',
        'Store':    '&lt;Store&gt;',
        # Unary operators.
        'Invert':   '~',
        'Not':      ' not ',
        'UAdd':     '+',
        'USub':     '-',
    }
    name = d.get(self.kind(node),'&lt;%s&gt;' % node.__class__.__name__)
    if strict: assert name,self.kind(node)
    return name
</t>
<t tx="ekr.20160126153212.73">

class StandAloneMakeStubFile:
    '''
    A class to make Python stub (.pyi) files in the ~/stubs directory for
    every file mentioned in the [Source Files] section of
    ~/stubs/make_stub_files.cfg.
    '''
    @others
</t>
<t tx="ekr.20160126153212.74">
def __init__ (self):
    '''Ctor for StandAloneMakeStubFile class.'''
    self.options = {}
    # Ivars set on the command line...
    self.config_fn = self.finalize('~/stubs/make_stub_files.cfg')
    self.enable_unit_tests = False
    self.files = [] # May also be set in the config file.
    self.trace = False # Trace pattern substitutions.
    self.verbose = False # Trace config arguments.
    # Ivars set in the config file...
    self.output_fn = None
    self.output_directory = self.finalize('~/stubs')
    self.overwrite = False
    self.prefix_lines = []
    self.trace = False
    self.warn = False
    # Pattern lists, set by config sections...
    self.arg_patterns = [] # [Arg Patterns]
    self.def_patterns = [] # [Def Name Patterns]
    self.general_patterns = [] # [General Patterns]
    self.post_return_patterns = [] # [Post Return Patterns]
    self.pre_return_patterns = [] # [Pre Return Patterns]
    self.return_patterns = [] # [Return Patterns]
</t>
<t tx="ekr.20160126153212.75">
def make_stub_file(self, fn):
    '''
    Make a stub file in ~/stubs for all source files mentioned in the
    [Source Files] section of ~/stubs/make_stub_files.cfg
    '''
    if not fn.endswith('.py'):
        print('not a python file', fn)
        return
    if not os.path.exists(fn):
        print('not found', fn)
        return
    base_fn = os.path.basename(fn)
    out_fn = os.path.join(self.output_directory, base_fn)
    out_fn = out_fn[:-3] + '.pyi'
    self.output_fn = os.path.normpath(out_fn)
    s = open(fn).read()
    node = ast.parse(s,filename=fn,mode='exec')
    StubTraverser(controller=self).run(node)
</t>
<t tx="ekr.20160126153212.76">
def run(self):
    '''
    Make stub files for all files.
    Do nothing if the output directory does not exist.
    '''
    if self.enable_unit_tests:
        self.run_all_unit_tests()
    dir_ = self.output_directory
    if dir_:
        if os.path.exists(dir_):
            for fn in self.files:
                self.make_stub_file(fn)
        else:
            print('output directory not found: %s' % dir_)
    else:
        print('no output directory')
</t>
<t tx="ekr.20160126153212.77">
def scan_command_line(self):
    '''Set ivars from command-line arguments.'''
    # This automatically implements the --help option.
    usage = "usage: make_stub_files.py [options] file1, file2, ..."
    parser = optparse.OptionParser(usage=usage)
    add = parser.add_option
    add('-c', '--config', dest='fn',
        help='full path to alternate configuration file')
    add('-d', '--dir', dest='dir',
        help='full path to the output directory')
    add('-o', '--overwrite', action='store_true', default=False,
        help='overwrite existing stub (.pyi) files')
    add('-t', '--trace', action='store_true', default=False,
        help='trace argument substitutions')
    add('-u', '--unit-test', action='store_true', default=False,
        help='enable unit tests at startup')
    add('-v', '--verbose', action='store_true', default=False,
        help='trace configuration settings')
    add('-w', '--warn', action='store_true', default=False,
        help='warn about unannotated args')
    # Parse the options
    options, args = parser.parse_args()
    # Handle the options...
    self.enable_unit_tests=options.unit_test
    self.overwrite = options.overwrite
    self.trace = self.trace or options.trace
    self.verbose = self.verbose or options.verbose
    self.warn = options.warn
    if options.fn:
        self.config_fn = options.fn
    if options.dir:
        dir_ = options.dir
        dir_ = self.finalize(dir_)
        if os.path.exists(dir_):
            self.output_directory = dir_
        else:
            print('--dir: directory does not exist: %s' % dir_)
            print('exiting')
            sys.exit(1)
    # If any files remain, set self.files.
    if args:
        args = [self.finalize(z) for z in args]
        if args:
            self.files = args
</t>
<t tx="ekr.20160126153212.78">def scan_options(self):
    '''Set all configuration-related ivars.'''
    verbose = self.verbose
    self.parser = parser = configparser.ConfigParser(dict_type=OrderedDict)
        # Requires Python 2.7
    parser.optionxform = str
    fn = self.finalize(self.config_fn)
    if os.path.exists(fn):
        if verbose:
            print('\nconfiguration file: %s\n' % fn)
    else:
        print('\nconfiguration file not found: %s' % fn)
        return
    parser.read(fn)
    if self.files:
        files_source = 'command-line'
        files = self.files
    else:
        files_source = 'config file'
        files = parser.get('Global', 'files')
        files = [z.strip() for z in files.split('\n') if z.strip()]
    files2 = []
    for z in files:
        files2.extend(glob.glob(self.finalize(z)))
    self.files = [z for z in files2 if z and os.path.exists(z)]
    if verbose:
        print('Files (from %s)...\n' % files_source)
        for z in self.files:
            print(z)
        print('')
    if 'output_directory' in parser.options('Global'):
        s = parser.get('Global', 'output_directory')
        output_dir = self.finalize(s)
        if os.path.exists(output_dir):
            self.output_directory = output_dir
            if verbose:
                print('output directory: %s\n' % output_dir)
        else:
            print('output directory not found: %s\n' % output_dir)
            self.output_directory = None # inhibit run().
    if 'prefix_lines' in parser.options('Global'):
        prefix = parser.get('Global', 'prefix_lines')
        self.prefix_lines = [z.strip() for z in prefix.split('\n') if z.strip()]
        if verbose:
            print('Prefix lines...\n')
            for z in self.prefix_lines:
                print(z)
            print('')
    self.arg_patterns = self.scan_patterns('Arg Patterns')
    self.def_patterns = self.scan_patterns('Def Name Patterns')
    self.general_patterns = self.scan_patterns('General Patterns')
    self.post_return_patterns = self.scan_patterns('Post Return Patterns')
    self.pre_return_patterns = self.scan_patterns('Pre Return Patterns')
    self.return_patterns = self.scan_patterns('Return Patterns')
</t>
<t tx="ekr.20160126153212.79">
def scan_patterns(self, section_name):
    '''Parse the config section into a list of patterns, preserving order.'''
    parser, verbose = self.parser, self.verbose
    aList = []
    if section_name in parser.sections():
        if verbose: print('%s...\n' % section_name)
        for key in parser.options(section_name):
            value = parser.get(section_name, key)
            # A kludge: strip leading \\ from patterns.
            if key.startswith(r'\\'):
                key = key[2:]
            pattern = Pattern(key, value, self.trace)
            aList.append(pattern)
            if verbose: print(pattern)
        if verbose: print('')
    elif verbose:
        print('no section: %s' % section_name)
        print(parser.sections())
        print('')
    return aList
</t>
<t tx="ekr.20160126153212.8">
# ClassDef(identifier name, expr* bases, stmt* body, expr* decorator_list)

def do_ClassDef(self, node):
    result = []
    name = node.name # Only a plain string is valid.
    bases = [self.visit(z) for z in node.bases] if node.bases else []
    if bases:
        result.append(self.indent('class %s(%s):\n' % (name, ','.join(bases))))
    else:
        result.append(self.indent('class %s:\n' % name))
    for z in node.body:
        self.level += 1
        result.append(self.visit(z))
        self.level -= 1
    return ''.join(result)
</t>
<t tx="ekr.20160126153212.80">

class StubFormatter (AstFormatter):
    '''
    Just like the AstFormatter class, except it prints the class
    names of constants instead of actual values.
    '''
    @others
</t>
<t tx="ekr.20160126153212.81">
# Return generic markers to allow better pattern matches.

def do_BoolOp(self, node): # Python 2.x only.
    return 'bool'

def do_Bytes(self, node): # Python 3.x only.
    return 'bytes' # return str(node.s)

def do_Name(self, node):
    return 'bool' if node.id in ('True', 'False') else node.id

def do_Num(self, node):
    return 'number' # return repr(node.n)

def do_Str(self, node):
    '''This represents a string constant.'''
    return 'str' # return repr(node.s)
</t>
<t tx="ekr.20160126153212.82">

class StubTraverser (ast.NodeVisitor):
    '''An ast.Node traverser class that outputs a stub for each class or def.'''
    @others
</t>
<t tx="ekr.20160126153212.83">
def __init__(self, controller):
    '''Ctor for StubTraverser class.'''
    self.controller = x = controller
        # A StandAloneMakeStubFile instance.
    # Internal state ivars...
    self.class_name_stack = []
    self.format = StubFormatter().format
    self.in_function = False
    self.level = 0
    self.output_file = None
    self.raw_format = AstFormatter().format
    self.returns = []
    self.warn_list = []
    # Copies of controller ivars...
    self.output_fn = x.output_fn
    self.overwrite = x.overwrite
    self.prefix_lines = x.prefix_lines
    self.trace = x.trace
    self.warn = x.warn
    # Copies of controller patterns...
    self.arg_patterns = x.arg_patterns
    self.def_patterns = x.def_patterns
    self.general_patterns = x.general_patterns
    self.post_return_patterns = x.post_return_patterns
    self.pre_return_patterns = x.pre_return_patterns
    self.return_patterns = x.return_patterns

</t>
<t tx="ekr.20160126153212.84">
def indent(self, s):
    '''Return s, properly indented.'''
    return '%s%s' % (' ' * 4 * self.level, s)

def out(self, s):
    '''Output the string to the console or the file.'''
    if self.output_file:
        self.output_file.write(self.indent(s)+'\n')
    else:
        print(self.indent(s))
</t>
<t tx="ekr.20160126153212.85">
def run(self, node):
    '''StubTraverser.run: write the stubs in node's tree to self.output_fn.'''
    fn = self.output_fn
    dir_ = os.path.dirname(fn)
    if os.path.exists(fn) and not self.overwrite:
        print('file exists: %s' % fn)
    elif not dir_ or os.path.exists(dir_):
        self.output_file = open(fn, 'w')
        for z in self.prefix_lines or []:
            self.out(z.strip())
        self.visit(node)
        self.output_file.close()
        self.output_file = None
        print('wrote: %s' % fn)
    else:
        print('output directory not not found: %s' % dir_)

</t>
<t tx="ekr.20160126153212.87">
# ClassDef(identifier name, expr* bases, stmt* body, expr* decorator_list)

def visit_ClassDef(self, node):

    # Format...
    if not node.name.startswith('_'):
        if node.bases:
            s = '(%s)' % ','.join([self.format(z) for z in node.bases])
        else:
            s = ''
        self.out('class %s%s:' % (node.name, s))
    # Visit...
    self.level += 1
    old_in_function = self.in_function
    self.in_function = False
    self.class_name_stack.append(node.name)
    for z in node.body:
        self.visit(z)
    self.class_name_stack.pop()
    self.level -= 1
    self.in_function = old_in_function
</t>
<t tx="ekr.20160126153212.88">
# FunctionDef(identifier name, arguments args, stmt* body, expr* decorator_list)

def visit_FunctionDef(self, node):
    
    # Do nothing if we are already in a function.
    # We do not generate stubs for inner defs.
    if self.in_function: # or node.name.startswith('_'):
        return
    # First, visit the function body.
    self.returns = []
    self.in_function = True
    self.level += 1
    for z in node.body:
        self.visit(z)
    self.level -= 1
    self.in_function = False
    # Format *after* traversing
    self.out('def %s(%s) -&gt; %s' % (
        node.name,
        self.format_arguments(node.args),
        self.format_returns(node)))
</t>
<t tx="ekr.20160126153212.89">
# arguments = (expr* args, identifier? vararg, identifier? kwarg, expr* defaults)

def format_arguments(self, node):
    '''
    Format the arguments node.
    Similar to AstFormat.do_arguments, but it is not a visitor!
    '''
    assert isinstance(node,ast.arguments), node
    args = [self.format(z) for z in node.args]
    defaults = [self.raw_format(z) for z in node.defaults]
    # Assign default values to the last args.
    result = []
    n_plain = len(args) - len(defaults)
    # pylint: disable=consider-using-enumerate
    for i in range(len(args)):
        s = self.munge_arg(args[i])
        if i &lt; n_plain:
            result.append(s)
        else:
            result.append('%s=%s' % (s, defaults[i - n_plain]))
    # Now add the vararg and kwarg args.
    name = getattr(node, 'vararg', None)
    if name: result.append('*' + name)
    name = getattr(node, 'kwarg', None)
    if name: result.append('**' + name)
    return ', '.join(result)
</t>
<t tx="ekr.20160126153212.9">
# FunctionDef(identifier name, arguments args, stmt* body, expr* decorator_list)

def do_FunctionDef(self, node):
    '''Format a FunctionDef node.'''
    result = []
    if node.decorator_list:
        for z in node.decorator_list:
            result.append('@%s\n' % self.visit(z))
    name = node.name # Only a plain string is valid.
    args = self.visit(node.args) if node.args else ''
    result.append(self.indent('def %s(%s):\n' % (name, args)))
    for z in node.body:
        self.level += 1
        result.append(self.visit(z))
        self.level -= 1
    return ''.join(result)
</t>
<t tx="ekr.20160126153212.90">
def format_returns(self, node):
    '''
    Calculate the return type:
    - Return None if there are no return statements.
    - Patterns in [Def Name Patterns] override all other patterns.
    - Otherwise, return a list of return values.
    '''
    # Shortcut everything if node.name matches any
    # pattern in self.def_patterns
    trace = self.trace
    name = self.get_def_name(node)
    r1 = [self.format(z) for z in self.returns]
        # Allow StubFormatter.do_Return to do the hack.
    # Step 1: Return None if there are no return statements.
    if trace and self.returns:
        g.trace('name: %s r:\n%s' % (name, r1))
    if not [z for z in self.returns if z.value != None]:
        return 'None: ...'
    # Step 2: [Def Name Patterns] override all other patterns.
    for pattern in self.def_patterns:
        find_s, repl_s = pattern.find_s, pattern.repl_s
        match = re.search(find_s, name)
        if match and match.group(0) == name:
            if trace:
                g.trace('*name pattern %s: %s -&gt; %s' % (find_s, name, repl_s))
            return repl_s + ': ...'
    # Step 3: munge each return value, and merge them.
    r = [self.munge_ret(name, z) for z in r1]
        # Make type substitutions.
    r = sorted(set(r))
        # Remove duplicates
    if len(r) == 0:
        return 'None: ...'
    if len(r) == 1:
        kind = None
    elif 'None' in r:
        r.remove('None')
        kind = 'Optional'
    else:
        kind = 'Union'
    return self.format_return_expressions(r1, r, kind)
</t>
<t tx="ekr.20160126153212.91">
def munge_arg(self, s):
    '''Add an annotation for s if possible.'''
    if s == 'self':
        return s
    default_pattern = None
    for patterns in (self.arg_patterns, self.general_patterns):
        for pattern in patterns:
            if pattern.find_s == '.*':
                default_pattern = pattern
                    # Match the default pattern last.
            else:
                # Succeed only if the entire pattern matches.
                if pattern.match_entire_string(s):
                    return '%s: %s' % (s, pattern.repl_s)
    if default_pattern:
        return '%s: %s' % (s, default_pattern.repl_s)
    else:
        if self.warn and s not in self.warn_list:
            self.warn_list.append(s)
            print('no annotation for %s' % s)
        return s
</t>
<t tx="ekr.20160126153212.92">
def munge_ret(self, name, s):
    '''replace a return value by a type if possible.'''
    trace = self.trace
    if trace: g.trace('====', name)
    # Match pre-patterns.
    for patterns in (self.pre_return_patterns, self.general_patterns):
        junk, s = self.match_return_patterns(name, patterns, s)
    # Repeatedly match return patterns.
    count, found = 0, True
    while found and count &lt; 50:
        count += 1
        found, s = self.match_return_patterns(name, self.return_patterns, s)
    # Match post-patterns.
    for patterns in (self.post_return_patterns, self.general_patterns):
        junk, s = self.match_return_patterns(name, patterns, s)
    if trace: g.trace('-----',s)
    return s
</t>
<t tx="ekr.20160126153212.93">
def match_return_patterns(self, name, patterns, s):
    '''
    Match all the given patterns, except the .* pattern.
    Return (found, s) if any succeed.
    '''
    trace = self.trace # or name.endswith('munge_arg')
    s1 = s
    default_pattern = None
    if trace: g.trace('===== %s: %s' % (name, s1))
    for pattern in patterns:
        if pattern.find_s == '.*':
            # The user should use [Def Name Patterns] instead.
            pass
        else:
            # Find all non-overlapping matches.
            # Replace the matches in reverse order.
            matches = pattern.all_matches(s, trace=trace)
            for m in reversed(matches):
                s = pattern.replace(m, s, trace=trace)
    found = s1 != s
    if trace and found:
        g.trace('returns %s\n' % s)
    return found, s
    
</t>
<t tx="ekr.20160126153212.99">
def visit_Return(self, node):

    self.returns.append(node)
        # New: return the entire node, not node.value.
</t>
<t tx="ekr.20160126153220.1"># An example configuration file for make_stub_files.py.
# By default, make_stub_files.py uses ~/stubs/make_stub_files.cfg.
# Can be changed using the --config=path command-line option.

[Global]

files:
    
    # Files to be used *only* if no files are given on the command line.
    # glob.glob wildcards are supported.
    
output_directory: ~/stubs
    
prefix_lines:
    # Lines to be inserted at the start of each stub file.

    from typing import TypeVar
    T = TypeVar('T', int, float, complex)
    
# Notes about patterns used below:
#
#  **Balanced patterns** contain either (*), [*], or {*}.
#  Unlike regular expressions, balanced patterns match only balanced brackets.
#
#  Both regex and balanced patterns may appear in each section.
#  However, balanced patterns will never match argument names.
#
#  Patterns are matched in the order they appear in each section,
#  but the .* pattern (if present) will match last, regardless of its
#  position in the section.
    
[Def Name Patterns]

# These regex patterns give the return types of functions or methods.
#
# Patterns for methods should match class_name.method_name.
#
# Patterns in this section *override* all other patterns,
# so you should use these patterns only if:
#
# - No other pattern properly handles the function or method, or
#
# - The pattern specifies functions that should all return the same value.
#   For example, all ast tree traversers should have the same signatures.
#
# It may be unwise to use .* in this section, but the choice is yours.

[Argument Patterns]

# The regex patterns in this section apply only when assigning types
# to *arguments* to functions or methods. Patterns match argument names.
# Typically, most patterns can be put [General Patterns] section instead.

[General Patterns]

# The patterns in this section may be either regex or balanced patterns.
# Patterns in this section are applied both to arguments and return expressions.
# These patterns are applied *once* to argument names and *repeatedly* to
# return types until no further matches can be made.

aList[1-3]?: Sequence
i: int
j: int
k: int
node: ast.Ast
s[1-3]?: str

[Return Patterns]

# The patterns in this section may be either regex or balanced patterns.
# Patterns in this section are applied only to return expressions.
# These patterns are applied *repeatedly* to return expressions
# until no further matches can be made.

# Balanced patterns...

repr(*): str
str.join(*): str
str.replace(*): str
str%(*): str
str%str: str

# Regex patterns...

.*__name__: str
</t>
<t tx="ekr.20160126165907.1">def finalize(self, fn):
    '''Finalize and regularize a filename.'''
    fn = os.path.expanduser(fn)
    fn = os.path.abspath(fn)
    fn = os.path.normpath(fn)
    return fn
</t>
<t tx="ekr.20160126172747.1">
def pdb():
    '''Invoke pdb in a way that can be used safely in Leo.'''
    try:
        import leo.core.leoGlobals as g
        g.pdb()
    except ImportError:
        import pdb
        pdb.set_trace()
</t>
<t tx="ekr.20160128041938.1">

class Pattern:
    '''
    A class representing regex or balanced patterns.
    
    Sample matching code, for either kind of pattern:
        
        for m in reversed(pattern.all_matches(s)):
            s = pattern.replace(m, s)
    '''
    @others
</t>
<t tx="ekr.20160128042705.1">
def all_matches(self, s, trace=False):
    '''Return a list of tubles (is_balanced, start, end) for all matches in s.'''
    trace = trace or self.trace
    if self.is_balanced():
        aList, i = [], 0
        while i &lt; len(s):
            progress = i
            j = self.full_balanced_match(s, i, trace=trace)
            if j is None:
                i += 1
            else:
                aList.append((i,j),)
                i = j
            assert progress &lt; i
        return aList
    else:
        return list(self.regex.finditer(s))
</t>
<t tx="ekr.20160128042857.1">
def is_balanced(self):
    '''Return True if self.s is a balanced pattern.'''
    s = self.find_s
    for pattern in ('(*)', '[*]', '{*}'):
        if s.find(pattern) &gt; -1:
            return True
    return False
</t>
<t tx="ekr.20160128045845.1">
def match_balanced(self, delim, s, i, trace=False):
    '''
    delim == s[i] and delim is in '([{'
    Return the index of the end of the balanced parenthesized string, or len(s)+1.
    '''
    assert s[i] == delim, s[i]
    assert delim in '([{'
    delim2 = ')]}'['([{'.index(delim)]
    assert delim2 in ')]}'
    i1, level = i, 0
    while i &lt; len(s):
        progress = i
        ch = s[i]
        i += 1
        if ch == delim:
            level += 1
        elif ch == delim2:
            level -= 1
            if level == 0:
                if trace: g.trace('found: %s' % s[i1:i])
                return i
        assert progress &lt; i
    # Unmatched: a syntax error.
    print('***** unmatched %s in %s' % (delim, s))
    return len(s) + 1
</t>
<t tx="ekr.20160128051025.1">
def full_balanced_match(self, s, i, trace=False):
    '''Return the index of the end of the match found at s[i:] or None.'''
    i1 = i
    trace = trace or self.trace
    pattern = self.find_s
    j = 0 # index into pattern
    while i &lt; len(s) and j &lt; len(pattern) and s[i] == pattern[j]:
        progress = i
        if pattern[j:j+3] in ('(*)', '[*]', '{*}'):
            delim = pattern[j]
            i = self.match_balanced(delim, s, i, trace=trace)
            j += 3
        else:
            i += 1
            j += 1
        assert progress &lt; i
    found = i &lt;= len(s) and j == len(pattern)
    if trace and found:
        g.trace('%s -&gt; %s' % (pattern, s[i1:i]))
    return i if found else None
</t>
<t tx="ekr.20160128102557.1"># An example configuration file for make_stub_files.py.
# By default, make_stub_files.py uses ~/stubs/make_stub_files.cfg.
# Can be changed using the --config=path command-line option.

[Global]

files:
    
    # Files to be used *only* if no files are given on the command line.
    # glob.glob wildcards are supported.
    
output_directory: ~/stubs
    
prefix_lines:
    # Lines to be inserted at the start of each stub file.

    from typing import TypeVar
    T = TypeVar('T', int, float, complex)
    
# Notes about patterns used below:
#
#  **Balanced patterns** contain either (*), [*], or {*}.
#  Unlike regular expressions, balanced patterns match only balanced brackets.
#
#  Both regex and balanced patterns may appear in each section.
#  However, balanced patterns will never match argument names.
#
#  Patterns are matched in the order they appear in each section,
#  but the .* pattern (if present) will match last, regardless of its
#  position in the section.
    
[Def Name Patterns]

# These regex patterns give the return types of functions or methods.
#
# Patterns for methods should match class_name.method_name.
#
# Patterns in this section *override* all other patterns,
# so you should use these patterns only if:
#
# - No other pattern properly handles the function or method, or
#
# - The pattern specifies functions that should all return the same value.
#   For example, all ast tree traversers should have the same signatures.
#
# It may be unwise to use .* in this section, but the choice is yours.

[Argument Patterns]

# The regex patterns in this section apply only when assigning types
# to *arguments* to functions or methods. Patterns match argument names.
# Typically, most patterns can be put [General Patterns] section instead.

[General Patterns]

# The patterns in this section may be either regex or balanced patterns.
# Patterns in this section are applied both to arguments and return expressions.
# These patterns are applied *once* to argument names and *repeatedly* to
# return types until no further matches can be made.

aList[1-3]?: Sequence
i: int
j: int
k: int
node: ast.Ast
s[1-3]?: str

[Return Patterns]

# The patterns in this section may be either regex or balanced patterns.
# Patterns in this section are applied only to return expressions.
# These patterns are applied *repeatedly* to return expressions
# until no further matches can be made.

# Balanced patterns...

repr(*): str
str.join(*): str
str.replace(*): str
str%(*): str
str%str: str

# Regex patterns...

.*__name__: str
</t>
<t tx="ekr.20160128104639.1">@language config

# A configuration file to make stubs for make_stub_files.py itself.

[Global]

files: make_stub_files.py
    
output_directory: .
    
prefix_lines:
    from typing import Any, Dict, Optional, Sequence, Tuple, Union
    # At present, I don't understand how to tell mypy about ast.Node
    # import ast
    # Node = ast.Node
    Node = Any

[Def Name Patterns]

AstFormatter.*: str
Pattern.all_matches: Sequence
Pattern.full_balanced_match: Optional[int]
Pattern.match_balanced: int
Pattern.match_entire_string: bool
StandAloneMakeStubFile.scan_types: Dict[str, str]
StubFormatter.do_.*: str
StubTraverser.format_returns: str
StubTraverser.match_return_patterns: Tuple[bool,str]
StubTraverser.match_return_pattern: Optional[str]
StubTraverser.match_balanced: int

[Arg Patterns]

# Default patterns should *only* appear here.
# Use [Def Name Patterns] to set default return types.

# Without the .* default, -w generates warnings for:
# delim, find_f, fn, name, pattern, repl_s, section_name

patterns: Sequence
trace: bool
controller: StandAloneMakeStubFile
parser: optparse.OptionParser
### .*: str

[General Patterns]

a: str
aList: Sequence

fn: str
\bi[0-3]?\b: int

node: Node
\bs[0-3]?\b: str
strict: bool

# Guido
group: str
ndots: int
os.sep.join(*): str

[Pre Return Patterns]

found: str
name: str
number: int

# These would be dangerous. Reversing the order would be wrong.
### \\[*]: List[*]
### (*):Tuple[*]

[Return Patterns]

all(*): bool
len(*): int
str%(*): str
str.join(*): str
\bstr\b\+\bstr\b: str
\bstr\b\+\bcomments\b: str
tuple(*): Tuple[*]

[Post Return Patterns]

str[*]: str
</t>
<t tx="ekr.20160128104714.1"></t>
<t tx="ekr.20160128105006.1"></t>
<t tx="ekr.20160128113859.1">
def __init__ (self, find_s, repl_s, trace=False):
    '''Ctor for the Pattern class.'''
   
    self.find_s = find_s
    self.repl_s = repl_s
    if self.is_balanced():
        self.regex = None
    else:
        # Careful: add sep only when the entire find_s is an identifier.
        sep = r'\b'
        s = find_s
        s2 = s.replace('_','')
        if s2 and s2[0].isalpha():
            s = sep + s + sep
        self.regex = re.compile(s)
    self.trace = trace
</t>
<t tx="ekr.20160128113914.1">
def __repr__(self):
    '''Pattern.__repr__'''
    return 'Pattern: %s ==&gt; %s' % (self.find_s, self.repl_s)
    
__str__ = __repr__
</t>
<t tx="ekr.20160128114726.1">
def match_entire_string(self, s, trace=False):
    '''Return True if s matches self.find_s'''
    if self.is_balanced():
        j = self.full_balanced_match(s, 0, trace=trace)
        return j is not None
    else:
        m = self.regex.match(s)
        return m and m.group(0) == s
</t>
<t tx="ekr.20160128122410.1">def get_def_name(self, node):
    '''Return the representaion of a function or method name.'''
    if self.class_name_stack:
        name = '%s.%s' % (self.class_name_stack[-1], node.name)
        # All ctors should return None
        if node.name == '__init__':
            name = 'None'
    else:
        name = node.name
    return name
</t>
<t tx="ekr.20160128154243.1">
def run_all_unit_tests(self):
    
    # pylint: disable=relative-import
    from test import test_msf
    import unittest
    loader = unittest.TestLoader()
    suite = loader.loadTestsFromTestCase(test_msf.TestMakeStubFiles)
    unittest.TextTestRunner(verbosity=0).run(suite)
</t>
<t tx="ekr.20160128154704.1"></t>
<t tx="ekr.20160128154715.1">import unittest
import make_stub_files as msf

class TestMakeStubFiles(unittest.TestCase):
    '''Main test class.'''
    @others
    
if __name__ == '__main__':
    unittest.main()</t>
<t tx="ekr.20160128190112.1">def test_pattern_class(self):
    
    trace = False
    table = (
        ('s', 's', 'str', 'str'),
        ('abc', 'abc', 'ABC', 'ABC'),
        ('str(str)', 'str(*)', 'str', 'str'),
        ('[str]', r'\[str\]', 'xxx', 'xxx'), # Guido bug.
        ('s3', r's[1-3]?\b', 'str', 'str'), # lengthening bug.
        ('[whatever]', '[*]', 'List[*]', 'List[whatever]'), # * on the RHS.
        ('(int,str)', '(*)', 'Tuple[*]', 'Tuple[int,str]'), # Guido bug 2.
    )
    for s, find, repl, expected in table:
        pattern = msf.Pattern(find, repl)
        result = pattern.match_entire_string(s, trace=trace)
        assert result, (result, s, find, repl, expected)
        aList = pattern.all_matches(s, trace=trace)
        assert len(aList) == 1, aList

</t>
<t tx="ekr.20160128190224.1">
def test_is_known_type(self):
    '''Test that is_known_type handles brackets reasonably.'''
    good = (
        'Any', 'Sequence',
        'Sequence[]',
        'Sequence[List]',
        'Sequence[List[Any]]',
        'Tuple[int,str]',
    )
    bad = (
        'Huh', 'Sequence(List)',
        'List+a',
        'List+List',
    )
    c = msf.StandAloneMakeStubFile()
    for s in good:
        assert msf.StubTraverser(c).is_known_type(s), s
    for s in bad:
        assert not msf.StubTraverser(c).is_known_type(s), s
</t>
<t tx="ekr.20160128190252.1"># def setUp(self):
    # '''Called before each test.'''
</t>
<t tx="ekr.20160128225533.1">*.pyc
test/*.pyc</t>
<t tx="ekr.20160130032546.1">
def format_return_expressions(self, aList1, aList, kind):
    '''
    aList is a list of return expressions.
    All patterns have been applied.
    For each expression e:
    - If e is a single known type, add e to the result.
    - Otherwise, add Any # e to the result.
    Return the properly indented result.
    '''
    comments, results, unknowns = [], [], False
    lws =  '\n' + ' '*4
    for i, e in enumerate(aList):
        comma = ',' if i &lt; len(aList) - 1 else ''
        comments.append('# return ' + e)
        results.append(e + comma)
        if not self.is_known_type(e):
            # g.trace('****', repr(e))
            unknowns = True
    if unknowns:
        comments1 = ['# return ' + e for e in list(set(aList1))]
        comments1 = [z for z in comments1 if z not in comments]
        sep = ['# reduced...'] if comments1 else []
        comments = ''.join([lws + self.indent(z) for z in comments1 + sep + comments])
        return 'Any: ...' + comments
    if kind == 'Union' and len(results) == 1:
        kind = None
    if len(results) == 1:
        s = results[0]
    else:
        s = ''.join([lws + self.indent(z) for z in results])
    if kind:
        s = '%s[%s]' % (kind, s)
    return s + ': ...'
    
</t>
<t tx="ekr.20160130034812.1">
def is_known_type(self, s):
    '''
    Return True if s is nothing but a single known type.
    Recursively test inner types in square brackets.
    '''
    if s in (
        'bool', 'bytes', 'complex', 'dict', 'float', 'int',
        'list', 'long', 'str', 'tuple', 'unicode',
    ):
        return True
    if s.startswith('[') and s.endswith(']'):
        return self.is_known_type(s[1:-1])
    table = (
        'AbstractSet', 'Any', 'AnyMeta', 'AnyStr',
        'BinaryIO', 'ByteString',
        'Callable', 'CallableMeta', 'Container',
        'Dict', 'Final', 'Generic', 'GenericMeta', 'Hashable',
        'IO', 'ItemsView', 'Iterable', 'Iterator',
        'KT', 'KeysView', 'List',
        'Mapping', 'MappingView', 'Match',
        'MutableMapping', 'MutableSequence', 'MutableSet',
        'NamedTuple', 'Optional', 'OptionalMeta',
        # 'POSIX', 'PY2', 'PY3',
        'Pattern', 'Reversible',
        'Sequence', 'Set', 'Sized',
        'SupportsAbs', 'SupportsFloat', 'SupportsInt', 'SupportsRound',
        'T', 'TextIO', 'Tuple', 'TupleMeta',
        'TypeVar', 'TypingMeta',
        'Undefined', 'Union', 'UnionMeta',
        'VT', 'ValuesView', 'VarBinding',
    )
    for s2 in table:
        if s2 == s:
            return True
        pattern = Pattern(s2+'[*]', s)
        if pattern.match_entire_string(s):
            # Look inside the square brackets.
            brackets = s[len(s2):]
            assert brackets and brackets[0] == '[' and brackets[-1] == ']'
            s3 = brackets[1:-1]
            if s3:
                return all([self.is_known_type(z) for z in s3.split(',')])
            else:
                return True
    return False
</t>
<t tx="ekr.20160131174909.1">@language rest
@wrap

** --infer.

** --update.

- Task oriented docs

- Preserve existing annotations?
  It doesn't seem urgent.
  The script would have to be run with Python 3.
</t>
<t tx="ekr.20160131175042.1">class TestClass:
    '''A class containing constructs that have caused difficulties.'''
    # pylint: disable=no-member
    # pylint: disable=undefined-variable
    # pylint: disable=no-self-argument
    # pylint: disable=no-method-argument
    @others</t>
<t tx="ekr.20160131175118.1">def return_list(self, a):
    return [a]</t>
<t tx="ekr.20160131180118.1">class LeoGlobals:
    '''A class supporting g.pdb and g.trace for compatibility with Leo.'''
    @others</t>
<t tx="ekr.20160131180244.1">def pdb(self):
    try:
        import leo.core.leoGlobals as leo_g
        leo_g.pdb()
    except ImportError:
        import pdb
        pdb.set_trace()
</t>
<t tx="ekr.20160131180306.1">def trace(self, *args, **keys):
    try:
        import leo.core.leoGlobals as leo_g
        leo_g.trace(caller_level=2, *args, **keys)
    except ImportError:
        print(args, keys)
</t>
<t tx="ekr.20160131192406.1">def return_all(self):
    return all([self.is_known_type(z) for z in s3.split(',')])
    # return all(['abc'])</t>
<t tx="ekr.20160131192735.1">def return_array():
    # return self.is_known_type(s[1:-1])
    return f(s[1:-1])</t>
<t tx="ekr.20160131204607.1">
def replace(self, m, s, trace=False):
    '''Use m (returned by all_matches) to replace the pattern in s.'''
    if self.is_balanced():
        start, end = m
    else:
        start, end = m.start(), m.end()
    s2 = s
    s_find = s[start+1:end-1]
    s_repl = self.repl_s
    if self.is_balanced():
        s_repl = s_repl.replace('*', s_find)
    s = s[:start] + s_repl + s[end:]
    if trace and s2 != s:
        sep = '\n' if len(s2) &gt; 20 or len(s) &gt; 20 else ' '
        g.trace('match: %s%s%s --&gt;%s%s' % (
            s_repl, sep, s2, sep, s))
    return s
</t>
<t tx="ekr.20160201125349.1">def parse_group(group):
    if len(group) &gt;= 3 and group[-2] == 'as':
        del group[-2:]
    ndots = 0
    i = 0
    while len(group) &gt; i and group[i].startswith('.'):
        ndots += len(group[i])
        i += 1
    assert ''.join(group[:i]) == '.'*ndots, group
    del group[:i]
    assert all(g == '.' for g in group[1::2]), group
    return ndots, os.sep.join(group[::2])
</t>
<t tx="ekr.20160201131557.1">@language rest
@wrap

How to turn (int,str) into Tuple[int, str]?

This pattern doesn't do it:

(int,str): Tuple[int, str]

Now the last line says

    # return (Tuple[int, str])</t>
<t tx="ekr.20160201151312.1"></t>
<t tx="ekr.20160201194801.1">
def do_Return(self, node):
    '''
    StubFormatter.do_Return.
    Result does not start with 'return' nor end with a newline.
    '''
    trace = False
    s = AstFormatter.do_Return(self, node)
    assert s.startswith('return'), repr(s)
    s = s[len('return'):].strip()
    # if trace: g.trace('(StubFormatter)', s)
    if s.startswith('(') and s.endswith(')'):
        # Defensive code: ensure the parens are balanced.
        i = Pattern('(*)', 'not-used').match_balanced(s[0], s, 0)
        if i == len(s):
            s1 = s
            s = 'Tuple[%s]' % s[1:-1]
            if trace: g.trace(s1, '==&gt;', s)
    elif s.startswith('[') and s.endswith(']'):
        # Defensive code: ensure the brackets are balanced.
        i = Pattern('[*]', 'not-used').match_balanced(s[0], s, 0)
        if i == len(s):
            s1 = s
            s = 'List[%s]' % s[1:-1]
            if trace: g.trace(s1, '==&gt;', s)
    return s
</t>
<t tx="ekr.20160201201820.1"></t>
</tnodes>
</leo_file>

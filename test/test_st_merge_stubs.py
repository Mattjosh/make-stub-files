import unittest
from make_stub_files import *

class test_st_merge_stubs (unittest.TestCase):
    def runTest(self):
        '''Test framework for st.update and helpers.'''
        # To do:
        # - Test between-stub lines and leading lines.
        # - Round-trip tests!
        import ast
        from collections import OrderedDict
            # Requires Python 2.7 or above. Without OrderedDict
            # the configparser will give random order for patterns.
        try:
            import ConfigParser as configparser # Python 2
        except ImportError:
            import configparser # Python 3
        import glob
        import optparse
        import os
        import re
        import sys
        import time
        try:
            import StringIO as io # Python 2
        except ImportError:
            import io # Python 3
        # To be INSERTED (They exist in new stubs, but not here.)
        # def is_known_type(s: str) -> Union[Any,bool]: ...
        # def reduce_numbers(aList: List[Any]) -> List[Any]: ...
        # class AstFormatter:
            # def format(self, node: Node) -> Union[Any,str]: ...
            # def visit(self, node: Node) -> str: ...
            # def do_ClassDef(self, node: Node) -> str: ...
            # def do_FunctionDef(self, node: Node) -> str: ...
        old_s = '''\
        def main() -> None: ...
        def merge_types(a1: Any, a2: Any) -> str: ...
        def pdb(self) -> None: ...
        def reduce_types(aList: List[Any], name: str=None, trace: bool=False) -> Any: ...
        class Pattern(object):
            def __init__(self, find_s: str, repl_s: str='') -> None: ...
            def __eq__(self, obj: Any) -> bool: ...
            def __ne__(self, obj: Any) -> bool: ...
            def __hash__(self) -> int: ...
            def __repr__(self) -> str: ...
            def is_balanced(self) -> bool: ...
            def is_regex(self) -> Any: ...
                #   0: return self.find_s.endswith('$')
                # ? 0: return self.find_s.endswith(str)
        '''
        # To be DELETED (They exist in old_stubs, but not here)
        # class Pattern(object):
            # def __init__(self, find_s: str, repl_s: str='') -> None: ...
            # def __eq__(self, obj: Any) -> bool: ...
            # def __ne__(self, obj: Any) -> bool: ...
            # def __hash__(self) -> int: ...
            # def __repr__(self) -> str: ...
            # def is_balanced(self) -> bool: ...
            # def is_regex(self) -> Any: ...
                # #   0: return self.find_s.endswith('$')
                # # ? 0: return self.find_s.endswith(str)
        new_s = '''\
        def is_known_type(s: str) -> Union[Any,bool]: ...
        def main() -> None: ...
        def merge_types(a1: Any, a2: Any) -> str: ...
        def pdb(self) -> None: ...
        def reduce_numbers(aList: List[Any]) -> List[Any]: ...
        def reduce_types(aList: List[Any], name: str=None, trace: bool=False) -> Any: ...
        class AstFormatter:
            def format(self, node: Node) -> Union[Any,str]: ...
            def visit(self, node: Node) -> str: ...
            def do_ClassDef(self, node: Node) -> str: ...
            def do_FunctionDef(self, node: Node) -> str: ...
        '''
        g = LeoGlobals() # Use the g available to the script.
        # g.cls()
        st = StubTraverser(controller=g.NullObject())
        # dump('old_s', old_s)
        # dump('new_s', new_s)
        old_d, old_root = st.parse_stub_file(old_s, root_name='<old-root>')
        new_d, new_root = st.parse_stub_file(new_s, root_name='<new-root>')
        if 0:
            dump_dict('old_d', old_d)
            dump_dict('new_d', new_d)
            print(st.trace_stubs(old_root, header='trace_stubs(old_root)'))
            print(st.trace_stubs(new_root, header='trace_stubs(new_root)'))
        if 0: # separate unit test. Passed.
            aList = st.sort_stubs_by_hierarchy(new_root)
            dump_list(aList, 'after sort_stubs_by_hierarcy')
        new_stubs = new_d.values()
        st.merge_stubs(new_stubs, old_root, new_root, trace=False)
        if 0:
            print(st.trace_stubs(old_root, header='trace_stubs(old_root)'))


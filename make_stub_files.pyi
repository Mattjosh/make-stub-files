
from typing import Any, Dict, Optional, Sequence, Tuple, Union
# At present, I don't understand how to tell mypy about ast.Node
# import ast
# Node = ast.Node
Node = Any
class AstArgFormatter(AstFormatter):
    def do_BoolOp(self, node: Node) -> str: ...
    def do_Bytes(self, node: Node) -> str: ...
    def do_Name(self, node: Node) -> Any: ...
    def do_Num(self, node: Node) -> str: ...
    def do_Str(self, node: Node) -> str: ...
class AstFormatter:
    def do_Assert(self, node: Node) -> str: ...
    def do_Assign(self, node: Node) -> str: ...
    def do_Attribute(self, node: Node) -> str: ...
    def do_AugAssign(self, node: Node) -> str: ...
    def do_AugLoad(self, node: Node) -> str: ...
    def do_BinOp(self, node: Node) -> str: ...
    def do_BoolOp(self, node: Node) -> str: ...
    def do_Break(self, node: Node) -> str: ...
    def do_Bytes(self, node: Node) -> str: ...
    def do_Call(self, node: Node) -> str: ...
    def do_ClassDef(self, node: Node) -> str: ...
    def do_Compare(self, node: Node) -> str: ...
    def do_Continue(self, node: Node) -> str: ...
    def do_Del(self, node: Node) -> str: ...
    def do_Delete(self, node: Node) -> str: ...
    def do_Dict(self, node: Node) -> str: ...
    def do_Ellipsis(self, node: Node) -> str: ...
    def do_ExceptHandler(self, node: Node) -> str: ...
    def do_Exec(self, node: Node) -> str: ...
    def do_Expr(self, node: Node) -> str: ...
    def do_Expression(self, node: Node) -> str: ...
    def do_ExtSlice(self, node: Node) -> str: ...
    def do_For(self, node: Node) -> str: ...
    def do_FunctionDef(self, node: Node) -> str: ...
    def do_GeneratorExp(self, node: Node) -> str: ...
    def do_Global(self, node: Node) -> str: ...
    def do_If(self, node: Node) -> str: ...
    def do_IfExp(self, node: Node) -> str: ...
    def do_Import(self, node: Node) -> str: ...
    def do_ImportFrom(self, node: Node) -> str: ...
    def do_Index(self, node: Node) -> str: ...
    def do_Interactive(self, node: Node) -> None: ...
    def do_Lambda(self, node: Node) -> str: ...
    def do_List(self, node: Node) -> str: ...
    def do_ListComp(self, node: Node) -> str: ...
    def do_Load(self, node: Node) -> str: ...
    def do_Module(self, node: Node) -> str: ...
    def do_Name(self, node: Node) -> str: ...
    def do_Num(self, node: Node) -> str: ...
    def do_Param(self, node: Node) -> str: ...
    def do_Pass(self, node: Node) -> str: ...
    def do_Print(self, node: Node) -> str: ...
    def do_Raise(self, node: Node) -> str: ...
    def do_Repr(self, node: Node) -> str: ...
    def do_Return(self, node: Node) -> str: ...
    def do_Slice(self, node: Node) -> str: ...
    def do_Store(self, node: Node) -> str: ...
    def do_Str(self, node: Node) -> str: ...
    def do_Subscript(self, node: Node) -> str: ...
    def do_TryExcept(self, node: Node) -> str: ...
    def do_TryFinally(self, node: Node) -> str: ...
    def do_Tuple(self, node: Node) -> str: ...
    def do_UnaryOp(self, node: Node) -> str: ...
    def do_While(self, node: Node) -> str: ...
    def do_With(self, node: Node) -> str: ...
    def do_Yield(self, node: Node) -> str: ...
    def do_arg(self, node: Node) -> str: ...
    def do_arguments(self, node: Node) -> str: ...
    def do_comprehension(self, node: Node) -> str: ...
    def do_keyword(self, node: Node) -> str: ...
    def format(self, node: Node) -> Union[Any, str]: ...
    def get_import_names(self, node: Node) -> Any: ...
        #   0: return result
        # ? 0: return result
    def indent(self, s: str) -> str: ...
    def kind(self, node: Node) -> Any: ...
        #   0: return node.__class__.__name__
        # ? 0: return Node.__class__.__name__
    def op_name(self, node: Node, strict: bool=True) -> str: ...
    def visit(self, node: Node) -> str: ...
class LeoGlobals:
    def _callerName(self, n: int=1, files=False) -> str: ...
    def callers(self, n: int=4, count=0, excludeCaller=True, files=False) -> Any: ...
        #   0: return sep.join(result)
        # ? 0: return sep.join(result)
    def cls(self) -> None: ...
    def pdb(self) -> None: ...
    def shortFileName(self, fileName, n: int=None) -> Any: ...
        #   0: return os.path.basename(fileName)
        # ? 0: return os.path.basename(fileName)
        #   1: return '/'.join(fileName.replace('\\','/').split('/')[-n:])
        #   1: return str
    def splitLines(self, s: str) -> Any: ...
    def trace(self, *args, **keys) -> None: ...
class Pattern(object):
    def __eq__(self, obj) -> Any: ...
        #   0: return self.find_s==obj.find_s and self.repl_s==obj.repl_s
        #   0: return bool
        #   1: return NotImplemented
        # ? 1: return NotImplemented
    def __hash__(self) -> int: ...
    def __init__(self, find_s: str, repl_s: str='') -> None: ...
    def __ne__(self, obj) -> bool: ...
    def __repr__(self) -> str: ...
    def all_matches(self, s: str) -> Any: ...
        #   0: return aList
        # ? 0: return aList
        #   1: return list(self.regex.finditer(s))
        # ? 1: return List[self.regex.finditer(str)]
    def full_balanced_match(self, s: str, i: int) -> Optional[str]: ...
    def is_balanced(self) -> bool: ...
    def is_regex(self) -> Any: ...
        #   0: return self.find_s.endswith('$')
        # ? 0: return self.find_s.endswith(str)
    def match(self, s: str) -> Tuple[bool, str]: ...
    def match_balanced(self, delim, s: str, i: int) -> number: ...
    def match_entire_string(self, s: str) -> Union[Any, bool]: ...
    def replace(self, m, s: str) -> Any: ...
        #   0: return self.replace_balanced(s,start,end)
        # ? 0: return self.replace_balanced(str,start,end)
        #   1: return self.replace_regex(m,s)
        # ? 1: return self.replace_regex(m,str)
    def replace_balanced(self, s1: str, start, end) -> Any: ...
        #   0: return s1[:start]+r+s1[end:]
        # ? 0: return str[:start]+r+str[end:]
        #   1: return s1[:start]+r+s1[end:]
        # ? 1: return str[:start]+r+str[end:]
        #   2: return s1[:start]+repl+s1[end:]
        # ? 2: return str[:start]+repl+str[end:]
    def replace_regex(self, m, s: str) -> str: ...
class StandAloneMakeStubFile:
    def __init__(self) -> None: ...
    def create_parser(self) -> Any: ...
        #   0: return parser
        # ? 0: return optparse.OptionParser
    def finalize(self, fn: str) -> str: ...
    def find_pattern_ops(self, pattern) -> Any: ...
        #   0: return ops
        # ? 0: return ops
    def get_config_string(self) -> str: ...
    def init_parser(self, s: str) -> None: ...
    def is_section_name(self, s: str) -> bool: ...
    def make_op_name_dict(self) -> Any: ...
        #   0: return d
        # ? 0: return d
    def make_patterns_dict(self) -> None: ...
    def make_stub_file(self, fn: str) -> None: ...
    def run(self) -> None: ...
    def run_all_unit_tests(self) -> None: ...
    def scan_command_line(self) -> None: ...
    def scan_options(self) -> None: ...
    def scan_patterns(self, section_name) -> Any: ...
        #   0: return aList
        # ? 0: return aList
class Stub(object):
    def __eq__(self, obj) -> Any: ...
        #   0: return self.name==obj.name
        #   0: return bool
        #   1: return NotImplemented
        # ? 1: return NotImplemented
    def __ge__(self, other) -> bool: ...
    def __gt__(self, obj) -> Any: ...
        #   0: return self.name>obj.name
        #   0: return bool
        #   1: return NotImplemented
        # ? 1: return NotImplemented
    def __hash__(self) -> Any: ...
        #   0: return self.parent.hash()+len(self.children)
        # ? 0: return self.parent.hash()+int
        #   1: return len(self.children)
        #   1: return int
    def __init__(self, kind, name: str, parent) -> None: ...
    def __le__(self, other) -> bool: ...
    def __lt__(self, other) -> bool: ...
    def __ne__(self, obj) -> bool: ...
    def __repr__(self) -> str: ...
    def full_name(self) -> Any: ...
        #   0: return '%s.%s'%(self.parent.full_name(), self.name)
        #   0: return str
        #   1: return self.name
        # ? 1: return self.name
class StubFormatter(AstFormatter):
    def __init__(self, controller: StandAloneMakeStubFile) -> None: ...
    def do_Attribute(self, node: Node) -> str: ...
    def do_BinOp(self, node: Node) -> str: ...
    def do_BoolOp(self, node: Node) -> str: ...
    def do_Bytes(self, node: Node) -> str: ...
    def do_Call(self, node: Node) -> str: ...
    def do_Compare(self, node: Node) -> str: ...
    def do_Dict(self, node: Node) -> str: ...
    def do_Ellipsis(self, node: Node) -> str: ...
    def do_ExtSlice(self, node: Node) -> str: ...
    def do_IfExp(self, node: Node) -> str: ...
    def do_Index(self, node: Node) -> str: ...
    def do_Name(self, node: Node) -> str: ...
    def do_Num(self, node: Node) -> str: ...
    def do_Repr(self, node: Node) -> str: ...
    def do_Return(self, node: Node) -> str: ...
    def do_Slice(self, node: Node) -> str: ...
    def do_Str(self, node: Node) -> str: ...
    def do_Subscript(self, node: Node) -> str: ...
    def do_Tuple(self, node: Node) -> str: ...
    def do_UnaryOp(self, node: Node) -> str: ...
    def do_arg(self, node: Node) -> str: ...
    def do_arguments(self, node: Node) -> str: ...
    def do_comprehension(self, node: Node) -> str: ...
    def do_keyword(self, node: Node) -> str: ...
    def match(self, patterns: List, s: str) -> str: ...
    def match_all(self, node: Node, s: str) -> str: ...
class StubTraverser(ast.NodeVisitor):
    def __init__(self, controller: StandAloneMakeStubFile) -> None: ...
    def format_arguments(self, node: Node) -> str: ...
    def format_return_expressions(self, raw_returns, reduced_returns) -> Any: ...
        #   0: return 'Any: ...'+results
        # ? 0: return str+results
        #   1: return s+': ...'
        #   1: return str
    def format_returns(self, node: Node) -> Any: ...
        #   0: return 'None: ...'
        #   0: return str
        #   1: return s+': ...'
        #   1: return str
        #   2: return self.format_return_expressions(raw,r)
        # ? 2: return self.format_return_expressions(raw,r)
    def get_def_name(self, node: Node) -> str: ...
    def get_stub_file(self, fn: str) -> str: ...
    def indent(self, s: str) -> str: ...
    def munge_arg(self, s: str) -> str: ...
    def out(self, s: str) -> None: ...
    def output_stubs(self, stub, sort_flag) -> None: ...
    def parse_stub_file(self, s: str) -> None: ...
    def run(self, node: Node) -> None: ...
    def update(self, fn: str) -> None: ...
    def visit_ClassDef(self, node: Node) -> None: ...
    def visit_FunctionDef(self, node: Node) -> None: ...
    def visit_Return(self, node: Node) -> None: ...
class TestClass:
    def parse_group(group: str) -> Tuple[int, str]: ...
    def return_all(self) -> bool: ...
    def return_array() -> Any: ...
        #   0: return f(s[1:-1])
        # ? 0: return f(str[number:number])
    def return_list(self, a: str) -> [str]: ...
    def return_two_lists(s: str) -> Any: ...
        #   0: return aList
        # ? 0: return aList
        #   1: return list(self.regex.finditer(s))
        # ? 1: return List[self.regex.finditer(str)]
def is_known_type(s: str) -> Any: ...
    #   0: return True
    #   0: return bool
    #   1: return is_known_type(s[1:-1])
    # ? 1: return is_known_type(str[number:number])
    #   2: return True
    #   2: return bool
    #   3: return all(is_known_type(z.strip()) for z in s3.split(','))
    #   3: return bool
    #   4: return True
    #   4: return bool
    #   5: return False
    #   5: return bool
def main() -> None: ...
def pdb(self) -> None: ...
def reduce_numbers(aList: List[Any]) -> Any: ...
    #   0: return aList
    # ? 0: return aList
def reduce_types(aList: List[Any]) -> str: ...
